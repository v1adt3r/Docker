# Основы Docker

## Архитектура Docker

Чтобы понять как наиболее эффективно использовать Docker и некоторые не вполне
очевидные его свойства, необходимо хотя бы в целом представлять себе, каким образом организована совместная работа
компонентов платформы, скрытых от пользователя.

![](img/4.1.png)

- в центре расположен демон Docker (Docker daemon), ответственный за создание, запуск и контроль
  работы контейнеров, а так же за создание и хранение образов. Контейнеры и образы представлены в 
  правой части диаграммы. Демон Docker запускается командой `docker daemon`, обычно об этом заботится
  ОС хоста;


- клиент Docker, размещенный в левой части диаграммы, используется для диалога с демоном Docker по 
  протоколу HTTP. По умолчанию это соединение устанавливается через сокет домена Unix, но также может
  использоваться TCP-сокет для поддержки соединений с удаленными клиентами или дискриптор файла для 
  сокетов, управляемый `systemd`. Так как все затруднения организовать соединене с удаленным демонами
  Docker и разработать привязки (bindings) к нужному языку программирования, но при этом следует учитывать
  особенности реализации этих возможностей, например обязательное наличие контекста создания
  (building context), описанного в соответствующем разделе данной книги. Интерфейсы прикладного 
  программирования, используемые для организации обмена данными с демоном, четко определены и 
  подробно документированы, что позволяет разработчиками писать программы, взаимодействующие 
  напрямую с демоном, без использования клиента Docker. Клиент и демон Docker распространяются 
  как отдельные независимые бинарные файлы;


- реестры Docker используют для хранения и расположения образов. Реестром, выбираемым по умолчанию, является 
  Docker Hub, на котором хранится тысячи общедоступных образов, а так же управляемые "официальные" образы.
  Многие организации создают собственные реестры, которые используются для хранения коммерческих и приватных 
  образов и для устранения накладных расходов, связанных с загрузкой образов через интернет. В разделе
  "Создание собственного реестра" содержится более подробная информация об организации и сопровождении
  нового частного реестра. Демон Docker загружает образы из реестров по запросу `docker pull`. Кроме того, 
  он выполняет автоматическую загрузку образов, указанных в запросе `docker run` и в инструкции `FROM` файла
  Dockerfile, если эти образы недоступны на локальной системе.

### Базовые технологии

Демон Docker использует "драйвер выполнения" (execution driver) для создания контейнеров. По умолчанию выбирается
собственный драйвер Docker `runc`, но, кроме того, обеспечивается поддержка более старого драйвера для 
механизма LXC. Драйвер `runc` очень тесно связан со следующими механизмами ядра:
- `cgroups` - механизм, отвечающий за управление ресурсами, используемыми контейнером (процессор, ОЗУ и тд).
Механизм `cgroups` так же обеспечивает выполнение операции замораживания контейнеров как поддержку функциональности
команды `docker pause`;


- `пространство имен (namespaces)` отвечают за изоляцию контейнеров, гарантируют что файловая система, имя хоста, 
пользователи, сетевая среда и процессы любого контейнера полностью отделены от остальной части системы.


`Libcontainer` также поддерживает `SElinux` и `AppArmor`, которые можно использовать для создания
более строгой системы безопасности. 

Еще одной основополагающей технологией для Docker является файловая система с каскадно-объединенным монтированием
(Union File System - UnionFS), обеспечивающая хранение уровней для контейнеров. Функциональность UnionFS
обеспечивается одним из нескольких драйверов файловой системы: `AUFS`, `devicemapper`, `BTRFS` или `Overlay`.

### Сопровождающие технологии

Сами по себе механизмы Docker и реестр Docker Hub не представляют завершенного полноценного решения
для работы с контейнерами. Для большинства пользователей потребуются сервисы поддержки и вспомогательное ПО,
например система управления кластерами, инструменты обнаружения сервисов, расширенные сетевые функциональные 
возможности и проч. Docker Inc. планирует создания полноценного решения "из коробки", включающего все требуемые
возможности, но позволяющего пользователям без труда заменять компоненты, установленные по умолчанию, на компоненты
сторонних производителей. Стратегия "заменяемых батареек" в первую очередь реализуется на уровне интерфейсов 
прикладного программирования, позволяя подключать компоненты непосредственно к движку Docker, но её так же можно
наблюдать на формировании дистрибутивных пакетов Docker как независимых автономных бинарных файлов, которые с легкостью
заменяются аналогами от третьих сторон.


На текущий момент можно привести следующий список технологий поддержи, предоставляемых Docker:
- `Swarm` - решение задачи кластеризации от Docker. `Swarm` позволяет сгруппировать несколько Docker-хостов,
после чего пользователь может работать с этой группой как с единым ресурсом.


- `Docker Compose` - инструмент для создания и выполнения приложений, скомпонованных из нескольких
Docker-контейнеров. Такие компоновки используются главным образом при разработке и тестировании, но 
гораздо реже в производственной среде. 


- `Docker Maсhine` - устанавливает и конфигурирует Docker-хосты на локальных и удаленных ресурсах. Кроме того, 
Maсhine конфигурирует клиента Docker, упрощая процедуру переключения между средами.


`Kitematic` представляет собой графический пользовательский интерфейс для Mac OS и Windows, обеспечивающий 
запуск и управление контейнеров Docker.

`Docker Trusted Registry` - локально устанавливаемое программное решение для хранения и управления образами
Docker Hub, которую можно объединить с существующей инфраструктурой обеспечения безопасности и согласовать
с правилами хранения и обеспечения защиты данных, принятых в конкретной организации. Все функциональные
возможности локального реестра, в том числе различные метрики, управление доступом на основе ролей и 
регистрационные журналы, контролируются через административную консоль. В настоящий момент это единиственный
программный продукт Docker Inc., исходный код которого закрыт.

Список сервисов и приложений третьих сторон, которые основаны на Docker или используют эту платформу, уже 
сейчас достаточно велик. Некоторые полноценные решения доступны в следующих областях:

- `сетевая среда` - создание сетей контейнеров, распределенных между разными хостами, представляет собой
непростую задачу, которую можно решить разнообразными способами. Недавно в этой области появилось
несколько решений, например [Weave](http://weave.works/net/) и [Project Calico](http://www.projectcalico.org/).
Кроме того, Docker намерен в ближайшем будущем представить комплексно сетевое решение под названием Overlay.
Пользователи смогут заменить драйвер Overlay на любые другие решения, использую подключаемую программную
рабочую среду для работы в сети;


- `обнаружение сервисов` - сразу после появления контейнеров Docker потребовался способ поиска других 
сервисов для взаимодействия с ним. Обычно такие сервисы также работают в контейнерах. Поскольку IP-адреса
присваиваются контейнерам динамически, задача обнаружения сервисов в больших системах достаточно 
сложна. К решениям в этой области относятся [Consul](https://consul.io/), [Registrator](https://github.com/gliderlabs/registrator)
, [SkyDNS](https://github.com/skynetservices/skydns/) и [etcd](https://github.com/coreos/etcd);


- `орекстровка и управление кластером` - при развертывании большого количества контейнеров весьма важно
наличие инструментов для контроля и управления всех системой в целом. Каждый новый контейнер должен быть
размещен на некотором хосте, его нужно контролировать и обновлять. Система должна правильно реагировать
на сбои или изменения нагрузки, перемещая, запуск или останавливая контейнеры соответствующим образом.
Здесь можно отметить несколько конкурирующих решений: [Kubernetes](http://kubernetes.io) от Google,
[Marathon](https://github.com/me-sosphere/marathon); фреймворк для [Mesos](https://mesos.apache.org),
[Fleet](https://github.com/coreos/fleet) от CoreOS, а также собственный инструмент Docker Swarm.

В дополнении к выше упомянутым подключаемым сетевым драйверам Docker поддерживает еще и _подключаемые тома_
_(volume plugins)_ для интеграции с другими системами хранения данных. Здесь особого внимания заслуживает
[Flocker](https://github.com/ClusterHQ/flocker), инструмент для управления данными и их перемещения 
в многохостовой системе, и [GlusterFS](https://github.com/calavera/docker-volume-glusterfs) для 
распределенного хранения данных. Более подробную информацию о фреймворке подключаемых драйверов
можно найти на [сайте](https://docs.docker.com/extend/plugins/).

Широкое распространение контейнеров привело к любопытному побочному эффекту, заключающемуся в появлении
нового поколения ОС, специализированных для поддержки контейнеров. Несмотря на то что Docker успешно
работает на большинстве современных дистрибутивов Linux, таких как Ubuntu, Red Hat и других, появились
проекты, направленные на создание облегченных и простых в сопровождении дистрибутивов, главной задачей
которых является только обеспечение работы контейнеров (или контейнеров и виртуальных машин), что особенно
важно для расширения функциональных возможностей центра обработки данных или кластера. В качестве примеров
можно привести [Project Atomic](http://www.projectatomic.io/), [CoreOS](https://coreos.com/), [RancherOS](http://rancher.com/rancher-os/).

### Хостинг для Docker

Многие известные облачные драйвера, в том числе Amazon, Google и Digital Ocean, уже предлагают определенный 
уровень поддержки Docker. Google Container Engine, возможно, является самым интересным вариантом, так как
создан непосредственно на платформе Kubernetes. Разумеется, даже если облачный провайдер не предлагает
прямую поддержку Docker, обычно имеет возможность представления виртуальных машин, в которых можно 
запускать Docker-контейнеры.

В этой области так же работает компания Joyent, предлагающая собственный механизм контейнеров под названием
Triton на основе SmartOS. С помощью реализации интерфейсов прикладного программирования Docker в своем механизме
контейнеров и технологии эмуляции Linux компания Joyent смогла создать общедоступный облачный сервис,
взаимодействующий со стандартным Docker клиентом. Более того, компания Joyent уверена, что ее реализация 
контейнера обладает высоким уровнем безопасности, позволяющим работать непосредственно с аппаратным обеспечением,
без необходимости размещения в виртуальной машине, а это может означать более высокую эффективность и существенное
сокращение накладных расходов, особенно с точки зрения операций ввода/вывода. 

Есть еще несколько проектов, организовавших PaaS-платформу на основе Docker, - [Deis](http://paz.sh), [Flynn](http://paz.sh) и [Paz](http://paz.sh)

## Как создаются образы

В этом разделе будет более подробно описано все происходящее при создании образа, а в конце
раздела приведено краткое руководство по различным инструкциям, используемым в Dockerfile. Всегда 
полезно понимать внутреннее функционирование команды создания, так как ее поведение иногда может 
становиться неожиданным.

### Контекст создания образа

Для команды `docker build` необходим Dockerfile и _контекст создания образа (build context)_ который может
быть пустым. 

Контекст создания - это набор локальных файлов и каталогов, к которым можно обращаться из инструкций
`ADD` и\или `COPY` в Dockerfile и которые обычно определяются как путь к нужному каталогу. Например,
команда создания образа `docker build -t test\cowsay-dockerfile .`, которая определяла контекст создания
как `.`, то есть текущий рабочий каталог. Все файлы и каталоги, расположенные по указанному пути, формируют
контекст создания образа и передаются в демон Docker как часть процесса создания.

В тех случаях, когда контекст не определен, - если задан только URL для Dockerfile или содержимое 
Dockerfile переедается по программному каналу из стандартного потока `STDIN`, - контекст создания данного
образа считается пустым.

> **Не следует использовать / в качастве контекста создания образа**
> 
> Поскольку контекст создания образа полностью включает tar-архив и передается в демон Docker, 
> не используйте для этой цели каталога, в котором содержится большое кол-во файлов. Например,
> если для контекста создания вы возьмете /home/user, Загрузки (Downloads) или /, то в результате
> получите длинную задержку, пока Docker-клиент будет упаковывать все файлы заданного каталога 
> и передавать их в демон.

Если задан URL, начинающийся с http или https, то предполагается, что это прямая ссылка на Dockerfile.
Маловероятно, что это окажется полезным, так как с файлом Dockerfile не связан какой-либо контекст
(а ссылки на архивы неприемлемы).

В качестве контекста создания образа разрешается указывать git-репозиторий. В этом случае клиент Docker
создаст клон такого репозитория и всех подчиненных модулей во временном каталоге, который затем 
передается в демон Docker как контекст создания образа. Docker воспринимает контекст как git-репозиторий,
если переданный путь начинается с префиксов `github.com/`, `git@` или `git://`. Вообще говоря, я рекомендую
избегать применения такого метода, вместо этого лучше перечислять репозиторий вручную - это более гибкий способ,
снижающий вероятность возникновения беспорядка.

Кроме того, клиент Docker способен принимать входные данные из стандартного потока ввода `STDIN`, если 
в команде указан аргумент `-` вместо контекста создания образа. Входными данными может быть либо 
Dockerfile без контекста (например, `docker build - < Dockerfile`), либо архивный файл, содержащий 
контекст, в том числе и Dockerfile (например, `docker build - < context.tar.gz`). Архивные файлы могут
передаваться в формате `tar.gz`, `xz`, или `bzip2`.

Размещение файла Dockerfile внутри контекста может быть указано с помощью аргумента `-f`
(например, `docker build -f dockerfile/Dockerfile.debug .`) Если нет прямого указания, то Docker попытается
найти файл с именем Dockerfile в корневом каталоге контекста.

> **Использование файла .dockeringnore**
> 
> Для удаления ненужных файлов из контекста создания образа можно воспользоваться файлом `.dockerignore`.
> Этот файл должен содержать имена исключаемых файлов, разделенных символами перехода на новую строку.
> Допускаются символы шаблнов `*` и `?.`. Например, можно сформировать `.dockerignore` со следующим содержимым:
> 
> .git`1`<br/>as
> 