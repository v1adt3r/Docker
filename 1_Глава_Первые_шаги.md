# Первые шаги

[Создание образов из файлов Dockerfile](#-создание-образов-из-файлов-Dockerfile)

## Запуск первого образа

Для проверки правильности установки Docker выполните следующие команды:
```shell
$ docker run debian echo "Hello World!"

Unable to find image 'debian:latest' locally
latest: Pulling from library/debian
bb7d5a84853b: Pull complete 
Digest: sha256:4d6ab716de467aad58e91b1b720f0badd7478847ec7a18f66027d0f8a329a43c
Status: Downloaded newer image for debian:latest
Hello, World
```
Мы выполнили команду `docker run`, инициализирующую запуск контейнеров. Аргумент `debian` - это имя образа.

Строка `Unable to find image 'debian:latest' locally` сообщает об отсуствии локальной копии образа Debian.
Затем Docker в онлайн режиме проверяет Docker Hub и загружает самую новую версиб образа Debian.

После загрузки и проверки образа, Docker помещает его в работающий контейнер и выполняет заданную команду
`echo Hello World!` внутри контейнера.

Если выполнить эту команду еще раз, то контейнер запустится немедленно, без предварительной загрузки образа.
Docker подготовит и запустит контейнер, выполнит команду `echo` и затем остановит контейнер.

C помощью Docker можно запустить shell внутри контейнера:
```shell
$ docker run -i -t debian /bin/bash

root@d77f6b23b959:/# echo "Hello, World!"
Hello, World!
root@d77f6b23b959:/# exit 
exit
```
Тут мы получили новый промпт командной строки внутри контейнера. Флаги `-i` и `-t` сообщают Docker, что необходимо
создать сеанс интерактивной работы на подключаемом терминальном устройстве `tty`. Команда `/bin/bash` инициализирует
командную оболочку bash. При выходе из командной оболочки контейнер прекратит работу - **контейнеры работают
пока существует их основной процесс**.

### Основные команды
Теперь займемся более подробным иследованием Docker, запуская контейнер и наблюдая в нем результаты выполнения
различных команд и действий. Сначала инициализируем новый контейнер, но в этот раз зададим для него имя хоста
с помозью флага `-h`:

```shell
$ docker run -h CONTAINER -i -t debian /bin/bash
root@CONTAINER:/# 

# Теперь сломаем контейнер:
root@CONTAINER:/# mv /bin /basket
root@CONTAINER:/# ls
bash: ls: command not found
```

Мы перенесли каталог `/bin` и сделали контейнер бесполезным, по крайней мере временно. Предже чем
покинуть сломаный контейнер, посмотрим, что нам могут сказать о нем команды `ps`, `inspect` и `diff`.
Откройте новый терминал (не завершая работу первого контейнер) и выполните команду `docker ps` прямо с хоста.

```shell
$ sudo docker ps                                     
[sudo] password for v1adt3r:  
CONTAINER ID   IMAGE        COMMAND           CREATED         STATUS         PORTS       NAMES
4dd70fb6d3bc   debian       "/bin/bash"       4 minutes ago   Up 4 minutes               happy_bardeen
```
Это позволяет нам узнать некие подробности обо всех контейнерах, работающих в текущий момент. Docker присвоил 
контейнеру удобное для чтения имя, которое может служить индентификатором контейнера на данном хосте, 
в нашем случае это `happy_bardeen`. 

Больше информации о контейнере мы получим с помощью `docker inspect`:
```shell
$ docker inspect happy_bardeen
    {
        "Id": "4dd70fb6d3bc6eaa37e938ee90678676caf0727b59042924c79866aa1a65f508",
        "Created": "2021-10-23T15:36:51.286684256Z",
        "Path": "/bin/bash",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
...
```
Можно воспользоваться утилитой `grep` или аргументом `--format`:
```shell
$ docker inspect happy_bardeen | grep IPAddress
            "SecondaryIPAddresses": null,
            "IPAddress": "172.17.0.2",
                    "IPAddress": "172.17.0.2",
```
или 
```shell
$ docker inspect --format {{.NetworkSettings.IPAddress}} happy_bardeen
172.17.0.2
```
Обе команды выдают IP-адрес работающиего контейнера. А теперь рассмотрим еще одну команду - `docker diff`:
```shell
$ docker diff happy_bardeen
D /bin
A /basket
A /basket/umount
A /basket/zfgrep
A /basket/gunzip
A /basket/more
A /basket/readlink
A /basket/stty
A /basket/dmesg
A /basket/nisdomainname
A /basket/cp
...
```
Здесь мы видим список файлов измененных в работающем контере; в данном случае это удаление каталога `/bin`
и добавлени его содержимого в каталог `/basket`.

Для контейнеров Docker использует файловую систему `UnionFS` которая позволяет монтировать несоклько
файловых систем в общую иерархию, которая выглядит как единая файловая система.

> Файловая система конкретного образа смонтирована как уровень только для чтения, а любые изменения
в работающем контейнере, происходят на уровне с разрешенной записью, монтируемого поверх основной 
файловой системы образа. Поэтому Docker при поиске изменений в работающей системе должен рассматривать
только самый верхний уровень, на котором возможна запись.

Если выполнить команду `docker logs` с указанием имени контейнера, то будет выведен список всех событий, 
произошедших внутри заданного контейнера:

```shell
$ docker logs happy_bardeen
root@CONTAINER:/# mv /bin /basket
root@CONTAINER:/# ls
bash: ls: command not found
```

Выйдем из командной оболочки контейнера:
```shell
$ exit
$
```
После этой команды `exit` завершит работу и сам контейнер. 

Если выполнить команду `docker ps`, то мы не увидим ни одного работающего контейнера.

После выполнения команды `docker ps -a` выводится список всех контейнеров, влючая остановленные `stopped`,
их еще называеют "контейнеры из которых был совершен выход" `exited containers`. Такие контейнеры могут быть
перезаущены командой `docker start`.

Чтобы избавиться от контейнера, следует воспользоваться командой `docker rm`:
```shell
$ docker rm happy_bardeen
happy_bardeen
```

> Удаление остановленых контейнеров
> Если нужно удалить все остановленные контейнеры, можно использовать результат
> выполнения команды `docker ps -aq -f status=exited` которая выводит резульаты всех остановленых
> контейнеров. Например:
> `docker rm -v $(docker ps -aq -f status=exited)`
> аргумент `-v` позволяет удалить все тома (разделы), управляемые Docker, на которые ссылаются какие-либо
> другие контейнеры.
> Избежать перезапуска ранее остановленых контейнеров можно, включив в команду `docker run` флаг `--rm`, который
> позволяет удалить остановленный контейнер и созданную на время его существования соответсвтующую файловую систему.

Теперь создадим приложение cowsay, работающее внутри Docker.

```shell
$ docker run -it --name cowsay --hostname cowsay debian bash
root@cowsay:/# apt-get update
Get:1 http://security.debian.org/debian-security bullseye-security InRelease [44.1 kB]
...
Get:6 http://deb.debian.org/debian bullseye-updates/main amd64 Packages [2300 B]                                                                                                                                                 
Fetched 8454 kB in 10s (827 kB/s)                                                                                                                                                                                                
Reading package lists... Done
root@cowsay:/# 

# Приступаем к работе:
root@cowsay:/# /usr/games/forune | /usr/games/cowsay
 __
<  >
 --
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```
Сохраним этот контейнер. Для превращений контейнера в образ, нужно всего лишь выполнить команду
`docker commit`. При этом не имеет значения, работает контейнер или он остановлен. Необходимо 
передать в команду имя контейнера `cowsay`, имя для создаваемого образа `cowsay image`, а так же 
имя репозитория, в котором образ будет сохранен `test`.

```shell
root@cowsay:/# exit 
exit

$ docker commit cowsay test/cowsayimage
sha256:7f536d2629a95bc63cec0999629413a015e60a6ab82f5b2090272b9c44ba84ea
```
Возвращаемое командой значение представляет собой уникальный идентификатор созданного образа. Теперь 
у нас есть образ с предустановленным приложением cowsay, который мы можем запускать в любое время:

```shell
$ docker run test/cowsayimage /usr/games/cowsay "Moo"
 _____
< Moo >
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```
Имеются некоторые затруднения. Если нужно что-то изменить, то нам придется вручную повторить все ранее 
проделанные операции. Например, если потребуется использовать другой основной образ ОС, то нам придется
выполнить процедуру с самого начала. Решение проблемы является в создании Dockerfile для создания образа
и автоматизированного повторного воспроизведения этой процедуры. 

## Создание образов из файлов Dockerfile

Dockerfile - это обычный текстовый файл, содержащий набор операций, которые могут быть использованы 
для создания Docker-образа. Сначала создадим новый каталог и Dockerfile:

```shell
$ mkdir cowsay
$ cd cowsay
$ touch Dockerfile
```
Затем в Dockerfile добавим следующее содержимое:

```dockerfile
FROM debian:wheezy

RUN apt-get update && apt-get install -y cowsay fortune
```


* Инструкция `FROM` определяет базовый образ ОС, конкретной версией `wheezy`.
* Инструкция `FROM` является строго обязательной для всех файлов Dockerfile как самая первая.
* Инструкции `RUN` определяют команды, выполняемые в командной оболочке внутри данного образа.

Теперь мы можем создать образ, выполнив команду `docker build` в том же каталоге, где наш Dockerfile:
```shell
$ docker build -t test/cowsay-dockerfile .
Step 1/2 : FROM debian:latest
 ---> f776cfb21b5e
Step 2/2 : RUN apt-get update && apt-get install -y cowsay fortune
 ---> Running in b669ee1f3752
...
Successfully tagged test/cowsay-dockerfile:latest

$ sudo docker run test/cowsay-dockerfile /usr/games/cowsay "Moo"
 _____
< Moo >
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```
После этого мы можем запускать образ точно таким же способом, как раньше:
```shell
$ docker run test/cowsay-dockerfile /usr/games/cowsay "Moo"
```
Выполнение этой задачи можно немного упростить для пользователя. 

Инструкция `ENTRYPOINT` позволяет определить выполняемый файл, который будет вызываться для 
обработки любых аргументов, переданных в команду `docker run`.

Добавим в конце нашего Dockerfile следующую строку:

`ENTRYPOINT ["/usr/games/cowsay"]`

Теперь нужно заново создать образ, после чего его можно запускать без указания команды `cowsay`:
```shell
$ docker build -t test/cowsay-dockerfile .
...
$ docker run test/cowsay-dockerfile "Mooo"
```

Запуск стал проще, но мы лишились возможности использования внутри контейнера команды `fortune`
в качестве генератора потока ввода для программы `cowsay`. Это можно исправить, если написать
специальный скрипт для инструкции `ENTRYPOINT` - обычное дело при создании Dockerfile.

В том же каталоге где расположен Dockerfile, создадим файл с именем `entrypoint.sh`:

```shell
#!/bin/bash
if [ $# -eq 0 ]; then
  /usr/games/fortune | /usr/games/cowsay
  else
    /usr/games/cowsay "$@"
fi
```
После создания необходимо сделать этот скрипт выполняемым `chmod +x entrypoint.sh`.

При вызове без аргументов скрипт создает программный канал для передачи потока вывода программы
`fortune` в поток ввода программы `cowsay` с передачей ей заданных аргументов.

Теперь необходимо изменить Dockerfile: добавить только что созданный файл в образ и вызвать
скрипт с инструкцией `ENTRYPOINT`. 

```dockerfile
FROM debian:latest

RUN apt-get update && apt-get install -y cowsay fortune
COPY entrypoint.sh /

ENTRYPOINT ["/entrypoint.sh"]
```

> Инструкция `COPY` просто копирует файлы из файловой системы хоста в файловую систему образа,
> где первый аргумент определяет файл хоста, а второй - целевой путь, таким образом, эта 
> инструкция очень похожа на обычную команду `cp`.

Попробуем создать новый образ и запустить контейнеры с аргументами и без них:

```shell
$ docker bind -t tetst/cowsay-dockerfile .
...
docker run test/cowsay-dockerfile
 _________________________________________
/ Youre almost as happy as you think you \
\ are.                                    /
 -----------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

$ docker run test/cowsay-dockerfile Hello Moo
 ___________
< Hello Moo >
 -----------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```

## Работа с реестрами

Так же как мы загружали образ `debian` из Docker Hub мы можем загружать и свой образ.

Для хранения образов применяется иерархическая система. При этом используются следующие термины:
 - реестр - сервис, отвечающий за хранение и распространение образов. По умолчанию используется 
 Docker Hub.
 - репозиторий - набор взаимосвязанных образов (обычно представляющих различные версии одно приложения 
или сервиса).
 - тег - алфавитно-цифровой идентификатор, присваиваемый образам внутри репозитория (например, 14.04 или stable).

Такими образом, команда `docker pull amouat/revealjs:lastest` загрузит образ с тегом `latest` в репозиторий
`amouat\revealjs` из реестра Docker Hub.

Для выгрузки в реестр нашего образа `cowsay` необходимо зарегистрироваться в ресстре Docker Hub.
После этого достаточно связать образ с соответствующим репозиторием и выполнить команду `docker push`
для выгрузки помеченного образа в Docker Hub. Но сначала добавим в Dockerfile инструкцию `MAINTAINER`,
которая определяет информацию, позволяющую связаться с автором данного образа:

```dockerfile
FROM debian:latest

MAINTAINER Vladimir Terechov <v1adt3r@gmail.com>
RUN apt-get update && apt-get install -y cowsay fortune
COPY entrypoint.sh /

ENTRYPOINT ["/entrypoint.sh"]
```

Теперь заново сгенерируем образ и выгрузим его в Docker Hub. Нужно чтобы имя репозитория начиналось с 
вашего имени в Docker Hub, потом слеш и имя выгружаемого образа:

```shell
$ docker build -t v1adt3r/cowsay .
...
$ docker push v1adt3r/cowsay
Using default tag: latest
The push refers to repository [docker.io/v1adt3r/cowsay]
4fbd681d0953: Pushed 
759a6660faef: Pushed 
62a747bf1719: Mounted from library/debian 
latest: digest: sha256:02fdb2d7e24d0be3ee04f0a6d2fa29929e391f32526810071b0ae99c7a1d1215 size: 948
```

## Использование официального образа Redis

Начнем с загрузки образа:

```shell
$ docker pull redis
Using default tag: latest
latest: Pulling from library/redis
7d63c13d9b9b: Pull complete 
a2c3b174c5ad: Pull complete 
283a10257b0f: Pull complete 
7a08c63a873a: Pull complete 
0531663a7f55: Pull complete 
9bf50efb265c: Pull complete 
Digest: sha256:a89cb097693dd354de598d279c304a1c73ee550fbfff6d9ee515568e0c749cfe
Status: Downloaded newer image for redis:latest
docker.io/library/redis:latest
```

Запустите контейнер Redis, но при этом используйте аргумент `-d`:
```shell
$ docker run --name myredis -d redis
f0bf91acbecca331612b56b45c4b5fdbda296449f823f55cb471c10f95d4030a
```
Аргумент `-d` сообщает Docker, что контейнер нужно запустить в фоновом режиме. Docker
начинает работу контейнера как обычно, но вместо вывода результатов из контейнера  возвращает его идентификатор и выполняет выход.
Контейнер продолжает работу в фоновом режиме, а чтобы увидеть вывод результатов из контейнера, можно  воспользоваться
командой `docker logs`.

Нужно установить связь с базой данных c помощью `redis-cli`. Создадим новый контейнер для запуска в нем 
`redis-cli` и установим соединение между двумя контейнерами:

```shell
$ docker run --rm -it --link myredis:redis redis /bin/bash
root@cdacc2620035:/data# redis-cli -h redis -p 6379
redis:6379> ping
PONG
redis:6379> set "abc" 123
OK
redis:6379> get "abc"
"123"
redis:6379> exit
root@cdacc2620035:/data# 
```

Мы только что установили соединение между двумя контейнерами и добавили данные в СУБД Redis буквально 
за несколько секунд.

> Будущие изменения в сетевой среде Docker
> 
> В этой главе как и во всех последующих для установления соединения между контейнерами в сети 
> используется команда `--link`. В будущем планируется изменения способов организации сетевой 
> работы Docker, вероятно, вместо установления соединения (link) между контейнерами будет
> использоваться более характерный для современной сетевой среды метод "публикации сервисов"
> Тем не менее в ближайшем будущем будет поддерживаться метод установления соединений, и для 
> корректного выполнения примеров из данной книги не потребуются какие-либо изменения.

Аргумент `--link myredis:redis` в команде `docker run` определяет установку соединения.

Docker получает информацию что нужно установить соединение между новым контейнером и сущесутвующим
`myredis`. В новом контейнере ссылка на существующих должна быть обозначена именем `redis`.

Docker создает в файле нового контейнера `/etc/hosts` запись `redis`, указывающую на IP-адрес контейнера 
`myredis`. Это повзоляет нам пользоваться имененм хоста `redis` непосредственно в командной строке
`redis-cli` без дополнительного определения пути к нему или поиска IP-адреса контейнера Redis.

Потом выполняет команда СУБД Redis `ping` для проверки правильности установленного соединения с Redis-сервером
перед добавлением каких-либо данных с помощью команд `set` и `put`.

Но остался вопрос: как сохранить наши данные и создать их резервную копию? Для этого не следует использовать
стандартную файловую систему контейнера, необходима возможность простого совместного использования хранилища
данных контейнером и хостом или другими контейнерами. Docker предоставляет такую возможность посредством 
реализации концепции томов.

Тома (volumes) - это файлы или каталоги, которые смонтированы непосредственно на хосте и не являются 
частью каскадно-объединенной файловой системы. Это означает, что другие контейнеры могут совместно 
использовать их, и все изменения будут сразу же фиксироваться в файловой системе хоста.

Существует два способа объявления каталога как тома: использование инструкции `VOLUME` в Dockerfile
или включение флага -v в команду `docker run`.  

Ниже приведены реализации обоих способов с одинаковым результатом - определение каталога `/data`
как тома внутри контейнера:

`VOLUME /data` или `docker run -v /data test/webserver`

По умолчанию заданный каталог или файл будет смонтирован на хосте внутри каталога, в котором был установлен
Docker (обычно это каталог `/var/lib/docker/`).

В качестве точки монтирования можно определить любой каталог хоста в команде `docker run`

`docker run -d -v /host/dir:/container/dir test/webserver`

В Dockerfile определить каталог хоста как точку монтирования невозможно по причинам, связанным с обеспечением
переносимости и безопасности (заданный файл или каталог может отсутствовать на других системах, а контейнерам 
нельзя предоставлять возможность монтирования критически важных файлов, подобных `/etc/passwd`, без явно
определенных прав доступа к ним).

Но как применить все описанное выше для создания резервных копиий содержимого контейнера Redis?

Ниже показан один способ, предпологается, что контейнер `myredis` продолжает работу:

```shell
$ docker run --rm -it --link myredis:redis redis /bin/bash
root@b21dc1f7cb2d:/data# redis-cli -h redis -p 6379
redis:6379> set "persistence" "test"
OK
redis:6379> save
OK
redis:6379> exit
root@b21dc1f7cb2d:/data# exit
exit
$ docker run --rm --volumes-from myredis -v $(pwd)/backup:/backup debian cp /data/dump.rdb /backup/
$ ls backup 
dump.rdb
$ ls backup 
dump.rdb
```

Обратите внимание на то, что аргумент `-v` использован для монтирования известного нам существующего каталога
хоста, а аргумент `--volumes-from` - для установления соединения между новым контейнером и каталогом базы данных
Redis. 

После завершения работы с контейнером myredis можно остановить и удалить его:
```shell
$ docker stop myredis
myredis
$ docker rm -v myredis
myredis
```

Все оставшиеся вспомогательные контейнеры можно удалить с помощью команды:
```shell
$ docker rm $(docker ps -aq)

## исключит из вывода все контейнеры в именах которых есть odds
docker ps -a | grep -v -E $(sudo docker ps -aq --filter='name=odds' | paste -sd "|" -)
```