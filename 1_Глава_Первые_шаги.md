# Первые шаги

## Запуск первого образа

Для проверки правильности установки Docker выполните следующие команды:
```shell
$ docker run debian echo "Hello World!"

Unable to find image 'debian:latest' locally
latest: Pulling from library/debian
bb7d5a84853b: Pull complete 
Digest: sha256:4d6ab716de467aad58e91b1b720f0badd7478847ec7a18f66027d0f8a329a43c
Status: Downloaded newer image for debian:latest
Hello, World
```
Мы выполнили команду `docker run`, инициализирующую запуск контейнеров. Аргумент `debian` - это имя образа.

Строка `Unable to find image 'debian:latest' locally` сообщает об отсуствии локальной копии образа Debian.
Затем Docker в онлайн режиме проверяет Docker Hub и загружает самую новую версиб образа Debian.

После загрузки и проверки образа, Docker помещает его в работающий контейнер и выполняет заданную команду
`echo Hello World!` внутри контейнера.

Если выполнить эту команду еще раз, то контейнер запустится немедленно, без предварительной загрузки образа.
Docker подготовит и запустит контейнер, выполнит команду `echo` и затем остановит контейнер.

C помощью Docker можно запустить shell внутри контейнера:
```shell
$ docker run -i -t debian /bin/bash

root@d77f6b23b959:/# echo "Hello, World!"
Hello, World!
root@d77f6b23b959:/# exit 
exit
```
Тут мы получили новый промпт командной строки внутри контейнера. Флаги `-i` и `-t` сообщают Docker, что необходимо
создать сеанс интерактивной работы на подключаемом терминальном устройстве `tty`. Команда `/bin/bash` инициализирует
командную оболочку bash. При выходе из командной оболочки контейнер прекратит работу - **контейнеры работают
пока существует их основной процесс**.

### Основные команды
Теперь займемся более подробным иследованием Docker, запуская контейнер и наблюдая в нем результаты выполнения
различных команд и действий. Сначала инициализируем новый контейнер, но в этот раз зададим для него имя хоста
с помозью флага `-h`:

```shell
$ docker run -h CONTAINER -i -t debian /bin/bash
root@CONTAINER:/# 

# Теперь сломаем контейнер:
root@CONTAINER:/# mv /bin /basket
root@CONTAINER:/# ls
bash: ls: command not found
```

Мы перенесли каталог `/bin` и сделали контейнер бесполезным, по крайней мере временно. Предже чем
покинуть сломаный контейнер, посмотрим, что нам могут сказать о нем команды `ps`, `inspect` и `diff`.
Откройте новый терминал (не завершая работу первого контейнер) и выполните команду `docker ps` прямо с хоста.

```shell
$ sudo docker ps                                     
[sudo] password for v1adt3r:  
CONTAINER ID   IMAGE        COMMAND           CREATED         STATUS         PORTS       NAMES
4dd70fb6d3bc   debian       "/bin/bash"       4 minutes ago   Up 4 minutes               happy_bardeen
```
Это позволяет нам узнать некие подробности обо всех контейнерах, работающих в текущий момент. Docker присвоил 
контейнеру удобное для чтения имя, которое может служить индентификатором контейнера на данном хосте, 
в нашем случае это `happy_bardeen`. 

Больше информации о контейнере мы получим с помощью `docker inspect`:
```shell
$ docker inspect happy_bardeen
    {
        "Id": "4dd70fb6d3bc6eaa37e938ee90678676caf0727b59042924c79866aa1a65f508",
        "Created": "2021-10-23T15:36:51.286684256Z",
        "Path": "/bin/bash",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
...
```
Можно воспользоваться утилитой `grep` или аргументом `--format`:
```shell
$ docker inspect happy_bardeen | grep IPAddress
            "SecondaryIPAddresses": null,
            "IPAddress": "172.17.0.2",
                    "IPAddress": "172.17.0.2",
```
или 
```shell
$ docker inspect --format {{.NetworkSettings.IPAddress}} happy_bardeen
172.17.0.2
```
Обе команды выдают IP-адрес работающиего контейнера. А теперь рассмотрим еще одну команду - `docker diff`:
```shell
$ docker diff happy_bardeen
D /bin
A /basket
A /basket/umount
A /basket/zfgrep
A /basket/gunzip
A /basket/more
A /basket/readlink
A /basket/stty
A /basket/dmesg
A /basket/nisdomainname
A /basket/cp
...
```
Здесь мы видим список файлов измененных в работающем контере; в данном случае это удаление каталога `/bin`
и добавлени его содержимого в каталог `/basket`.

Для контейнеров Docker использует файловую систему `UnionFS` которая позволяет монтировать несоклько
файловых систем в общую иерархию, которая выглядит как единая файловая система.

> Файловая система конкретного образа смонтирована как уровень только для чтения, а любые изменения
в работающем контейнере, происходят на уровне с разрешенной записью, монтируемого поверх основной 
файловой системы образа. Поэтому Docker при поиске изменений в работающей системе должен рассматривать
только самый верхний уровень, на котором возможна запись.

Если выполнить команду `docker logs` с указанием имени контейнера, то будет выведен список всех событий, 
произошедших внутри заданного контейнера:

```shell
$ docker logs happy_bardeen
root@CONTAINER:/# mv /bin /basket
root@CONTAINER:/# ls
bash: ls: command not found
```

Выйдем из командной оболочки контейнера:
```shell
$ exit
$
```
После этой команды `exit` завершит работу и сам контейнер. 

Если выполнить команду `docker ps`, то мы не увидим ни одного работающего контейнера.

После выполнения команды `docker ps -a` выводится список всех контейнеров, влючая остановленные `stopped`,
их еще называеют "контейнеры из которых был совершен выход" `exited containers`. Такие контейнеры могут быть
перезаущены командой `docker start`.

Чтобы избавиться от контейнера, следует воспользоваться командой `docker rm`:
```shell
$ docker rm happy_bardeen
happy_bardeen
```

> Удаление остановленых контейнеров
> Если нужно удалить все остановленные контейнеры, можно использовать результат
> выполнения команды `docker ps -aq -f status=exited` которая выводит резульаты всех остановленых
> контейнеров. Например:
> `docker rm -v $(docker ps -aq -f status=exited)`
> аргумент `-v` позволяет удалить все тома (разделы), управляемые Docker, на которые ссылаются какие-либо
> другие контейнеры.
> Избежать перезапуска ранее остановленых контейнеров можно, включив в команду `docker run` флаг `--rm`, который
> позволяет удалить остановленный контейнер и созданную на время его существования соответсвтующую файловую систему.

Теперь создадим приложение cowsay, работающее внутри Docker.

```shell
$ docker run -it --name cowsay --hostname cowsay debian bash
root@cowsay:/# apt-get update
Get:1 http://security.debian.org/debian-security bullseye-security InRelease [44.1 kB]
...
Get:6 http://deb.debian.org/debian bullseye-updates/main amd64 Packages [2300 B]                                                                                                                                                 
Fetched 8454 kB in 10s (827 kB/s)                                                                                                                                                                                                
Reading package lists... Done
root@cowsay:/# 

# Приступаем к работе:
root@cowsay:/# /usr/games/forune | /usr/games/cowsay
 __
<  >
 --
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```
Сохраним этот контейнер. Для превращений контейнера в образ, нужно всего лишь выполнить команду
`docker commit`. При этом не имеет значения, работает контейнер или он остановлен. Необходимо 
передать в команду имя контейнера `cowsay`, имя для создаваемого образа `cowsay image`, а так же 
имя репозитория, в котором образ будет сохранен `test`.

```shell
root@cowsay:/# exit 
exit

$ docker commit cowsay test/cowsayimage
sha256:7f536d2629a95bc63cec0999629413a015e60a6ab82f5b2090272b9c44ba84ea
```
Возвращаемое командой значение представляет собой уникальный идентификатор созданного образа. Теперь 
у нас есть образ с предустановленным приложением cowsay, который мы можем запускать в любое время:

```shell
$ docker run test/cowsayimage /usr/games/cowsay "Moo"
 _____
< Moo >
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```
Имеются некоторые затруднения. Если нужно что-то изменить, то нам придется вручную повторить все ранее 
проделанные операции. Например, если потребуется использовать другой основной образ ОС, то нам придется
выполнить процедуру с самого начала. Решение проблемы является в создании Dockerfile для создания образа
и автоматизированного повторного воспроизведения этой процедуры. 

## Создание образов из файлов Dockerfile

Dockerfile - это обычный текстовый файл, содержащий набор операций, которые могут быть использованы 
для создания Docker-образа. Сначала создадим новый каталог и Dockerfile:

```shell
$ mkdir cowsay
$ cd cowsay
$ touch Dockerfile
```
Затем в Dockerfile добавим следующее содержимое:

`FROM debian:wheezy`\
`RUN apt-get update && apt-get install -y cowsay fortune`

* Инструкция `FROM` определяет базовый образ ОС, конкретной версией `wheezy`.
* Инструкция `FROM` является строго обязательной для всех файлов Dockerfile как самая первая.
* Инструкции `RUN` определяют команды, выполняемые в командной оболочке внутри данного образа.

Теперь мы можем создать образ, выполнив команду `docker build` в том же каталоге, где наш Dockerfile:
```shell
$ docker build -t test/cowsay-dockerfile .
Step 1/2 : FROM debian:latest
 ---> f776cfb21b5e
Step 2/2 : RUN apt-get update && apt-get install -y cowsay fortune
 ---> Running in b669ee1f3752
...
Successfully tagged test/cowsay-dockerfile:latest

$ sudo docker run test/cowsay-dockerfile /usr/games/cowsay "Moo"
 _____
< Moo >
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```
После этого мы можем запускать образ точно таким же способом, как раньше:
```shell
$ docker run test/cowsay-dockerfile /usr/games/cowsay "Moo"
```