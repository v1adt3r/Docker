# Первые шаги

### Запуск первого образа

Для проверки правильности установки Docker выполните следующие команды:
```shell
$ docker run debian echo "Hello World!"

Unable to find image 'debian:latest' locally
latest: Pulling from library/debian
bb7d5a84853b: Pull complete 
Digest: sha256:4d6ab716de467aad58e91b1b720f0badd7478847ec7a18f66027d0f8a329a43c
Status: Downloaded newer image for debian:latest
Hello, World
```
Мы выполнили команду `docker run`, инициализирующую запуск контейнеров. Аргумент `debian` - это имя образа.

Строка `Unable to find image 'debian:latest' locally` сообщает об отсуствии локальной копии образа Debian.
Затем Docker в онлайн режиме проверяет Docker Hub и загружает самую новую версиб образа Debian.

После загрузки и проверки образа, Docker помещает его в работающий контейнер и выполняет заданную команду
`echo Hello World!` внутри контейнера.

Если выполнить эту команду еще раз, то контейнер запустится немедленно, без предварительной загрузки образа.
Docker подготовит и запустит контейнер, выполнит команду `echo` и затем остановит контейнер.

C помощью Docker можно запустить shell внутри контейнера:
```shell
$ docker run -i -t debian /bin/bash

root@d77f6b23b959:/# echo "Hello, World!"
Hello, World!
root@d77f6b23b959:/# exit 
exit
```
Тут мы получили новый промпт командной строки внутри контейнера. Флаги `-i` и `-t` сообщают Docker, что необходимо
создать сеанс интерактивной работы на подключаемом терминальном устройстве `tty`. Команда `/bin/bash` инициализирует
командную оболочку bash. При выходе из командной оболочки контейнер прекратит работу - **контейнеры работают
пока существует их основной процесс**.

### Основные команды
Теперь займемся более подробным иследованием Docker, запуская контейнер и наблюдая в нем результаты выполнения
различных команд и действий. Сначала инициализируем новый контейнер, но в этот раз зададим для него имя хоста
с помозью флага `-h`:

```shell
$ docker run -h CONTAINER -i -t debian /bin/bash
root@CONTAINER:/# 

# Теперь сломаем контейнер:
root@CONTAINER:/# mv /bin /basket
root@CONTAINER:/# ls
bash: ls: command not found
```

Мы перенесли каталог `/bin` и сделали контейнер бесполезным, по крайней мере временно. Предже чем
покинуть сломаный контейнер, посмотрим, что нам могут сказать о нем команды `ps`, `inspect` и `diff`.
Откройте новый терминал (не завершая работу первого контейнер) и выполните команду `docker ps` прямо с хоста.

```shell
$ sudo docker ps                                     
[sudo] password for v1adt3r:  
CONTAINER ID   IMAGE        COMMAND           CREATED         STATUS         PORTS       NAMES
4dd70fb6d3bc   debian       "/bin/bash"       4 minutes ago   Up 4 minutes               happy_bardeen
```
Это позволяет нам узнать некие подробности обо всех контейнерах, работающих в текущий момент. Docker присвоил 
контейнеру удобное для чтения имя, которое может служить индентификатором контейнера на данном хосте, 
в нашем случае это `happy_bardeen`. 

Больше информации о контейнере мы получим с помощью `docker inspect`:
```shell
$ docker inspect happy_bardeen
    {
        "Id": "4dd70fb6d3bc6eaa37e938ee90678676caf0727b59042924c79866aa1a65f508",
        "Created": "2021-10-23T15:36:51.286684256Z",
        "Path": "/bin/bash",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
...
```
Можно воспользоваться утилитой `grep` или аргументом `--format`:
```shell
$ docker inspect happy_bardeen | grep IPAddress
            "SecondaryIPAddresses": null,
            "IPAddress": "172.17.0.2",
                    "IPAddress": "172.17.0.2",
```
или 
```shell
$ docker inspect --format {{.NetworkSettings.IPAddress}} happy_bardeen
172.17.0.2
```
Обе команды выдают IP-адрес работающиего контейнера. А теперь рассмотрим еще одну команду - `docker diff`:
```shell
$ docker diff happy_bardeen
D /bin
A /basket
A /basket/umount
A /basket/zfgrep
A /basket/gunzip
A /basket/more
A /basket/readlink
A /basket/stty
A /basket/dmesg
A /basket/nisdomainname
A /basket/cp
...
```
Здесь мы видим список файлов измененных в работающем контере; в данном случае это удаление каталога `/bin`
и добавлени его содержимого в каталог `/basket`.

Для контейнеров Docker использует файловую систему `UnionFS` которая позволяет монтировать несоклько
файловых систем в общую иерархию, которая выглядит как единая файловая система.

> Файловая система конкретного образа смонтирована как уровень только для чтения, а любые изменения
в работающем контейнере, происходят на уровне с разрешенной записью, монтируемого поверх основной 
файловой системы образа. Поэтому Docker при поиске изменений в работающей системе должен рассматривать
только самый верхний уровень, на котором возможна запись.

Если выполнить команду `docker logs` с указанием имени контейнера, то будет выведен список всех событий, 
произошедших внутри заданного контейнера:

```shell
$ docker logs happy_bardeen
root@CONTAINER:/# mv /bin /basket
root@CONTAINER:/# ls
bash: ls: command not found
```

Выйдем из командной оболочки контейнера:
```shell
$ exit
$
```
После этой команды `exit` завершит работу и сам контейнер. 

Если выполнить команду `docker ps`, то мы не увидим ни одного работающего контейнера. 